import os
import json

#Source
topdir= '/srv/pypi/web/packages/source' #'/srv/pypi/web/packages/source/Z'

setup = 'setup.py'
reqs = {}
prereqs = {}
noReqCount = []
problematicPackages = []
mcounter = 0
counter = 0


#Iterates through the directory
for dirpath,dirnames, files in os.walk(topdir):
	for name in files:
		#checks if it's the setup script
		if(os.path.join(dirpath,name).count("/") < 10):
			

			try:
			
				#The name of the package
				packageName = dirpath[dirpath.rfind('/')+1:len(dirpath)]
				#Check if the filename is setup.py
				if name == setup:
					print packageName
					counter = counter + 1
					print counter
					strings = ""
					#Location of file
					print(os.path.join(dirpath,name))
					#Open the file
					datafile = file(os.path.join(dirpath,name))
					#checks to see if install_requires or requires exist, otherwise use requires.txt
					v = datafile.read().replace(' ',"")
					if 'install_requires=[' in v:
						req = 'install_requires=['
					elif 'requires=[' in v:
						req = 'requires=['
					else:
						req = 'requires.txt'
			
					print req
					openBracket  = 0
					datafile.close()
					datafile = file(os.path.join(dirpath,name))
					#read the file without the comments and no spaces			
					for line in datafile:
						#Takes out the comments from the file
						if '#' in line:
							line = line[0:line.find('#')]
						#Takes out the space 
						x = line.replace(' ',"")
						#Determine whether to read the setup.py file or the requires.txt file
						if req!= 'requires.txt':
							#Add to the string variable Strings once it finds the location of req
							if req in x:
								strings = strings + x
								strings= strings[strings.find('[')+1:len(strings)+1]
								#checks for cases where install_requires[apple[lol], dsds]
								openBracket = strings.count('[') - strings.count(']') + 1
							#ends the loop after reaching the end of requirement with ']'
							elif ']' in strings and openBracket==0:
								break;
							#Keep on adding onto Strings
							elif strings!= "":
								strings = strings + x
								openBracket = strings.count('[') - strings.count(']')
						else:
							#Reads data from requires.txt file which is often located in packageName.egg-info directory
							if (strings == ""):
								for dirpath,dirnames, files in os.walk(os.path.join(dirpath,'')):
									
										for name in files:
											
											try:
												if name == 'requires.txt':
													
													#Opens the file
													megfile = file(os.path.join(dirpath,name))
													#Read the file
													for theLine in megfile:
														
														if '#' in theLine:
															theLine = theLine[0:theLine.find('#')]
														#Checks for cases for requirements of [test] or [dev] 
														if '[' in theLine:
														
															break
												
														strings = strings + theLine
														
											
											
										




											except Exception:
												print "oops"
												continue
			
							
					
					datafile.close()
					#Some packages has requirements like [Django,]
					if ',]' in strings:
						strings = strings.replace(',]', ']')
					if ']' in strings:
						strings= strings[0:strings.find(']')]
					#Checks for cases where the string only contains \r or \n and replaces ,\n with a space
					strings = strings.replace(',\n',' ')
					if(len(strings) < 3):
						strings = strings.replace('\n',"")
					strings = strings.replace('\r',"")
				
					
					#Adds the packages without requirement into the list noReqCount				
					strRot = len(strings)	
					print repr(strings)
					if strings == "":
						noReqCount.append(packageName)
				
					#checks if it has '(' if it does look at the requirements.txt
					else:
						#Checks to see if string contains '(' which under my assumption it would be a method call or contain requirement info such as numpy(<=1.2)
						if '(' in strings:		
							#Make sure it's not numpy(<=1.2) before going to check requirements.txt
							if not (strings[strings.find('(')+1]=='<' or strings[strings.find('(')+1]=='>' or strings[strings.find('(')+1]=='='):
								#Reset the string to empty 
								strings =""
								#Loops through the string and check for requirements.txt
								for dirpath,dirnames, files in os.walk(os.path.join(dirpath,'')):
									for name in files:
									
										try:
											if name == 'requirements.txt':
												
											
												reqfile = file(os.path.join(dirpath,name))
												#Checks for cases where there are multiple requirements.txt file and it redirects to another folder such as -r /etc/requirements.txt
												if not 'requirements.txt' in reqfile.read().replace(' ',""):
												
													#CAN THROW EXCEPTION HERE but since reqfile.read() already read the file any more reading would generate '' because it's already eof
													reqfile.close()
													#Re-opens file so we can read after close
													reqfile = file(os.path.join(dirpath,name))
												#Reads line by line from file and add to string
												for aline in reqfile:
												
													if '#' in aline:
														aline = aline[0:aline.find('#')]
													strings = strings + aline
											
											
										




										except Exception:
											continue
			

					
						#Formats the solution by taking out the commas and single quotes and split the dependencies into a list
						#To enable formats like Cheetah>1.0,<=2.2.1
						strings = strings.replace(' ','')
						newString = strings.replace("','", ' ')
						newStringw = newString.replace('","', ' ')
						newStringr = newStringw.replace("\',\"", ' ')
						newStringt = newStringr.replace("\",\'", ' ')
						newStringv = newStringt.replace('"','')
						newStringu = newStringv.replace("'","")
									
						#Split the dependencies into a list
						newStringx = newStringu.split()
						print newStringx

						


				
						#Package name is key and list of dependency is value
						reqsCount = []
						for u in newStringx:
							reqsCount.append(u)
						reqs[packageName] = reqsCount

						#Dictionary with key as required package and value contain all packages that need it
						for u in newStringx:
							#Take out version number - packageNames = packageName[0:packageName.rfind('-')]'''
							'''if '>' in u:
								u = u[0:u.find('>')] 
							elif '<' in u:
								u = u[0:u.find('<')]
							elif '==' in u:
								u = u[0:u.find('==')]

							if u[len(u) - 1] == '(':
								u = u[0:len(u)-2]
							'''
							#Check if key already exists else creates one
							if u in prereqs:
								if packageName not in prereqs[u]:
									prereqs[u].append(packageName)
							else:
								prereqs[u] = []
								prereqs[u].append(packageName)
			except Exception:
				problematicPackages.append(packageName)									
				continue

			
				
				
#Writes the dictionary and list to a file
print counter
print mcounter

with open("probGetPak.txt",'w') as e:
	for s in problematicPackages:
		e.write(s + '\n')

with open("noReq.txt",'w') as f:
	for s in noReqCount:
		f.write(s + '\n')

with open("reqs.txt",'w') as g:
	for s in reqs:
		g.write(s + ": ")
		for x in reqs[s]:
			g.write(' - ' + x)
		g.write('\n')	
		g.write('\n')	

with open("prereqs.txt",'w') as v:
	for s in prereqs:
		v.write(s + ": ")
		for x in prereqs[s]:
			v.write(' - ' + x)
		v.write('\n')	
		v.write('\n')	
			
json.dump(reqs, open("req.txt",'w'))
				
			
		 
			
